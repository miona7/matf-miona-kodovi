%{
    #include <iostream>
    #include <cstdio>
    #include <string>
    #include <map>
    #include <bitset>

    extern int yylex(); // povezuje lekser sa parserom jer on radi samo sa tokenima a ne sa tekstualnim fajlom
    extern int yylex_destroy(); // brise lekser tj oslobadja alociranu memoriju

    void yyerror(const std::string& s) {
        std::cerr << "sintaksna greska: " << s << std::endl;
        exit(EXIT_FAILURE);
    }

    void ispisi(char c, int izraz) {
        if(c == 'b') {
            std::cout << std::bitset<8*sizeof(int)>(izraz) << std::endl;
        } else if(c == 'h') {
            std::cout << std::hex << izraz << std::dec << std::endl;
        } else if (c == 'd') {
            std::cout << izraz << std::endl;
        } else {
            yyerror("nedozvoljen format");
        }
    }

    std::map<std::string, int> promenljive;
%}

%union {
    std::string* s;
    int b;
    char c;
}

%token DEF PRINT EQ NEQ GEQ LEQ 
%token<s> ID
%token<b> BROJ
%token<c> FORMAT

%type<b> izraz logicka_naredba

%left '|'
%left '^'
%left '&' 
%left SHL SHR
%left '+' '-'
%left '*' '/' '%'
%right '~'
%right UMINUS

%start program

%%

program: niz_naredbi { }
    ;

niz_naredbi: naredba ';' niz_naredbi { }
    | naredba ';' { }
    ;

naredba: DEF ID {
        if(promenljive.find(*$2) != promenljive.end()) {
            yyerror("promenljiva je definisana");
        }
        promenljive[*$2] = 0;
        delete $2;
    }
    | DEF ID '=' izraz {
        if(promenljive.find(*$2) != promenljive.end()) {
            yyerror("promenljiva je definisana");
        }
        promenljive[*$2] = $4;
        delete $2;
    }
    | ID '=' izraz {
        if(promenljive.find(*$1) == promenljive.end()) {
            yyerror("promenljiva nije definisana");
        }
        promenljive[*$1] = $3;
        delete $1;
    }
    | PRINT '(' '"' FORMAT '"' ',' izraz ')' { ispisi($4, $7); }
    | logicka_naredba { std::cout << ($1 == 1 ? "True" : "False") << std::endl; }
    ;

izraz: izraz '+' izraz { $$ = $1 + $3; }
    | izraz '-' izraz { $$ = $1 - $3; }
    | izraz '*' izraz { $$ = $1 * $3; }
    | izraz '/' izraz { $$ = $1 / $3; }
    | izraz '%' izraz { $$ = $1 % $3; }
    | '-' izraz %prec UMINUS { $$ = -$2; }
    | '(' izraz ')' { $$ = $2; }
    | izraz '&' izraz { $$ = $1 & $3; }
    | izraz '|' izraz { $$ = $1 | $3; }
    | izraz '^' izraz { $$ = $1 ^ $3; }
    | '~' izraz { $$ = ~$2; }
    | izraz SHL BROJ { $$ = $1 << $3; }
    | izraz SHR BROJ { $$ = $1 >> $3; }
    | ID {
        auto it = promenljive.find(*$1);
        if(it == promenljive.end()) {
            yyerror("promeljiva nije definisana");
        }
        $$ = it->second;
        delete $1;
    }
    | BROJ { $$ = $1; }
    ;

logicka_naredba: izraz '<' izraz { $$ = $1 < $3; }
    | izraz '>' izraz { $$ = $1 > $3; }
    | izraz GEQ izraz { $$ = $1 >= $3; }
    | izraz LEQ izraz { $$ = $1 <= $3; }
    | izraz EQ izraz { $$ = $1 == $3; }
    | izraz NEQ izraz { $$ = $1 != $3; }
    ;

%%

int main() {

    if(yyparse() == 0) {
        std::cout << "sve ok" << std::endl;
    } else {
        yyerror("");
    }

    yylex_destroy();
    exit(EXIT_SUCCESS);
}