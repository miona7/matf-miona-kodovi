%{
    #include <iostream>
    #include <cstdlib>
    #include <string>
    #include <map>
    #include <algorithm>

    extern int yylex();
    extern int yylex_destroy();

    void yyerror(const std::string& s) {
        std::cerr << "sintaksna greska: " << s << std::endl;
        exit(EXIT_FAILURE);
    }

    std::map<std::string, std::string> promenljive;
%}

%union {
    std::string* s;
}

%token START END STRING STD_OUTPUT STD_ERROR STD_INPUT PRINT_ALL SHL SHR IF ELSE NO_ELSE EQ NEQ
%token<s> ID string

%type<s> izraz logicka_naredba

%left '+'
%left '*'
%right '~'

%start program

%%

program: START ':' niz_naredbi END { }
    ;

niz_naredbi: naredba ';' niz_naredbi { }
    | naredba ';' { }
    ;

naredba: STRING ID {
        if(promenljive.find(*$2) != promenljive.end()) {
            yyerror("promenljiva je def");
        }
        promenljive[*$2] = "";
        delete $2;
    }
    | STRING ID '=' izraz {
        if(promenljive.find(*$2) != promenljive.end()) {
            yyerror("promenljiva je def");
        }
        promenljive[*$2] = *$4;
        delete $2; delete $4;
    }
    | ID '=' izraz {
        if(promenljive.find(*$1) == promenljive.end()) {
            yyerror("promenljiva nije def");
        }
        promenljive[*$1] = *$3;
        delete $1; delete $3;
    }
    | STD_OUTPUT SHL izraz { std::cout << *$3 << std::endl; delete $3; }
    | STD_ERROR SHL izraz { std::cerr << *$3 << std::endl; delete $3; }
    | STD_OUTPUT SHL logicka_naredba { std::cout << *$3 << std::endl; delete $3; }
    | STD_ERROR SHL logicka_naredba { std::cerr << *$3 << std::endl; delete $3; }
    | STD_INPUT SHR ID {
        std::string s;
        std::cin >> s;

        if(promenljive.find(*$3) == promenljive.end()) {
            yyerror("promenljiva nije def");
        }
        promenljive[*$3] = s;
        delete $3;
    }
    | PRINT_ALL {
        for(auto it : promenljive) {
            std::cout << it.first << ": " << it.second << std::endl;
        } 
    }
    | IF '(' logicka_naredba ')' '{' niz_naredbi '}' %prec NO_ELSE { delete $3; }
    | IF '(' logicka_naredba ')' '{' niz_naredbi '}' ELSE '{' niz_naredbi '}' { delete $3; }
    ;

izraz: izraz '+' izraz { $$ = new std::string(*$1 + *$3); delete $1; delete $3; }
    | izraz '*' izraz {
        std::string rez = "";
        for(size_t i = 0; i < $1->size() - 1 && i < $3->size() - 1 && (*$1)[i] == (*$3)[i]; i++) {
            rez += (*$1)[i];
        }
        $$ = new std::string(rez);
        delete $1; delete $3;
    }
    | '~' izraz {
        std::string rez = *$2;
        std::reverse(rez.begin(), rez.end());
        $$ = new std::string(rez);
        delete $2;
    }
    | '(' izraz ')' { $$ = $2; }
    | ID {
        auto it = promenljive.find(*$1);
        if(it == promenljive.end()) {
            yyerror("promenljiva nije def");
        }
        $$ = new std::string(it->second);
        delete $1;
    }
    | string { $$ = new std::string($1->substr(1, $1->size() - 2)); delete $1; }
    ;

logicka_naredba: izraz EQ izraz {
        if(*$1 == *$3) {
            $$ = new std::string("1");
        } else {
            $$ = new std::string("0");
        }
        delete $1; delete $3;
    }
    | izraz NEQ izraz {
        if(*$1 != *$3) {
            $$ = new std::string("1");
        } else {
            $$ = new std::string("0");
        }
        delete $1; delete $3;
    }
    ;

%%

int main() {
    if(yyparse() == 0) {
        std::cout << "sve ok" << std::endl;
    } else {
        yyerror("");
    }

    yylex_destroy();
    exit(EXIT_SUCCESS);
}